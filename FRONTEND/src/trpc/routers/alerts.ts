import { z } from 'zod';
import { observable } from '@trpc/server/observable';
import { createTRPCRouter, publicProcedure, protectedProcedure } from '../init';
import { TRPCError } from '@trpc/server';
import { getRegionByCoordinates, regions } from '../../lib/regions';
import {
    checkCycloneAlerts,
    checkPollutionAlerts,
    checkStormSurgeAlerts,
    checkCoastalErosionAlerts,
    getAlertStats
} from '../../lib/alert-monitor';
import { sendEmail, sendSMS } from '@/lib/notifications';

const AlertTypeEnum = z.enum(['CYCLONE', 'STORM_SURGE', 'COASTAL_EROSION', 'WATER_POLLUTION']);
const AlertSeverityEnum = z.enum(['LOW', 'MODERATE', 'HIGH', 'EXTREME']);
const AlertStatusEnum = z.enum(['GENERATED', 'PENDING_APPROVAL', 'APPROVED', 'REJECTED', 'SENT']);

export const alertsRouter = createTRPCRouter({
    // Create a new alert (auto-generated when thresholds are met)
    createAlert: publicProcedure
        .input(z.object({
            type: AlertTypeEnum,
            severity: AlertSeverityEnum,
            title: z.string(),
            description: z.string(),
            region: z.string(),
            state: z.string(),
            coordinates: z.object({
                lat: z.number(),
                lng: z.number(),
            }).optional(),
            predictionData: z.any(), // Raw sensor/prediction data
            mlPrediction: z.number().min(0).max(1),
        }))
        .mutation(async ({ ctx, input }) => {
            try {
                const alert = await ctx.db.alert.create({
                    data: {
                        type: input.type,
                        severity: input.severity,
                        status: 'GENERATED', // Always start as GENERATED, require manual approval
                        title: input.title,
                        description: input.description,
                        region: input.region,
                        state: input.state,
                        coordinates: input.coordinates ? input.coordinates : undefined,
                        predictionData: input.predictionData,
                        mlPrediction: input.mlPrediction,
                        thresholdMet: true,
                        autoGenerated: true,
                    },
                });

                return {
                    success: true,
                    alert,
                };
            } catch (error) {
                console.error('Error creating alert:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to create alert',
                });
            }
        }),

    // Get all generated alerts (for dashboard)
    getGeneratedAlerts: publicProcedure
        .input(z.object({
            limit: z.number().min(1).max(100).default(20),
            offset: z.number().min(0).default(0),
            type: AlertTypeEnum.optional(),
            severity: AlertSeverityEnum.optional(),
            state: z.string().optional(),
            region: z.string().optional(),
        }))
        .query(async ({ ctx, input }) => {
            try {
                const where: any = {
                    status: {
                        in: ['GENERATED', 'PENDING_APPROVAL'],
                    },
                };

                if (input.type) where.type = input.type;
                if (input.severity) where.severity = input.severity;
                if (input.state) where.state = input.state;
                if (input.region) where.region = input.region;

                const [alerts, total] = await Promise.all([
                    ctx.db.alert.findMany({
                        where,
                        orderBy: { createdAt: 'desc' },
                        take: input.limit,
                        skip: input.offset,
                        include: {
                            reviewedBy: {
                                select: {
                                    id: true,
                                    firstName: true,
                                    lastName: true,
                                    role: true,
                                },
                            },
                        },
                    }),
                    ctx.db.alert.count({ where }),
                ]);

                return {
                    alerts,
                    total,
                    hasMore: input.offset + input.limit < total,
                };
            } catch (error) {
                console.error('Error fetching generated alerts:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to fetch generated alerts',
                });
            }
        }),

    // Get all approved alerts (trusted alerts)
    getApprovedAlerts: publicProcedure
        .input(z.object({
            limit: z.number().min(1).max(100).default(20),
            offset: z.number().min(0).default(0),
            type: AlertTypeEnum.optional(),
            severity: AlertSeverityEnum.optional(),
            state: z.string().optional(),
            region: z.string().optional(),
        }))
        .query(async ({ ctx, input }) => {
            try {
                const where: any = {
                    status: {
                        in: ['APPROVED', 'SENT'],
                    },
                };

                if (input.type) where.type = input.type;
                if (input.severity) where.severity = input.severity;
                if (input.state) where.state = input.state;
                if (input.region) where.region = input.region;

                const [alerts, total] = await Promise.all([
                    ctx.db.alert.findMany({
                        where,
                        orderBy: { approvedAt: 'desc' },
                        take: input.limit,
                        skip: input.offset,
                        include: {
                            reviewedBy: {
                                select: {
                                    id: true,
                                    firstName: true,
                                    lastName: true,
                                    role: true,
                                },
                            },
                        },
                    }),
                    ctx.db.alert.count({ where }),
                ]);

                return {
                    alerts,
                    total,
                    hasMore: input.offset + input.limit < total,
                };
            } catch (error) {
                console.error('Error fetching approved alerts:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to fetch approved alerts',
                });
            }
        }),

    // Admin: Get pending alerts for review
    getPendingAlerts: protectedProcedure
        .input(z.object({
            limit: z.number().min(1).max(100).default(20),
            offset: z.number().min(0).default(0),
        }))
        .query(async ({ ctx, input }) => {
            const userId = ctx.user?.id;
            if (!userId) {
                throw new TRPCError({ code: 'UNAUTHORIZED', message: 'User not found' });
            }

            try {
                // Check if user is admin
                const user = await ctx.db.user.findUnique({
                    where: { email: ctx.user?.email ?? "" },
                    select: { role: true, id: true },
                });

                // if (!user || user.role !== 'ADMIN') {
                //     throw new TRPCError({ code: 'FORBIDDEN', message: 'Admin access required' });
                // }

                const [alerts, total] = await Promise.all([
                    ctx.db.alert.findMany({
                        where: {
                            status: 'PENDING_APPROVAL',
                        },
                        orderBy: { createdAt: 'desc' },
                        take: input.limit,
                        skip: input.offset,
                    }),
                    ctx.db.alert.count({
                        where: { status: 'PENDING_APPROVAL' },
                    }),
                ]);

                return {
                    alerts,
                    total,
                    hasMore: input.offset + input.limit < total,
                };
            } catch (error) {
                console.error('Error fetching pending alerts:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to fetch pending alerts',
                });
            }
        }),

    // Admin: Approve an alert
    approveAlert: protectedProcedure
        .input(z.object({
            alertId: z.number(),
            reviewNotes: z.string().optional(),
        }))
        .mutation(async ({ ctx, input }) => {
            const userId = ctx.user?.id;
            if (!userId) {
                throw new TRPCError({ code: 'UNAUTHORIZED', message: 'User not found' });
            }

            try {
                // Check if user is admin
                const user = await ctx.db.user.findUnique({
                    where: { email: ctx.user?.email ?? "" },
                    select: { role: true, id: true },
                });

                // if (!user || user.role !== 'ADMIN') {
                //     throw new TRPCError({ code: 'FORBIDDEN', message: 'Admin access required' });
                // }

                const alert = await ctx.db.alert.update({
                    where: { id: input.alertId },
                    data: {
                        status: 'APPROVED',
                        reviewedById: user!.id,
                        reviewNotes: input.reviewNotes,
                        approvedAt: new Date(),
                    },
                    include: {
                        reviewedBy: {
                            select: {
                                firstName: true,
                                lastName: true,
                            },
                        },
                    },
                });
                // get the user for this region
                // {"lat":13.08784,"lng":80.27847}
                // getRegionByCoordinates(alert.region.)
                // alert.region -> city 
                // alert.state -> state
                // prisma get all user who have this subscriptuon
                const subscribers = await ctx.db.user.findMany({
                    where: {
                        subscriptions: {
                            some: {
                                active: true,
                                state: alert.state,
                                city: alert.region
                            }
                        }
                    },
                    select: {
                        email: true,
                        phone: true,
                        kindeId: true,
                        firstName: true,
                        lastName: true
                    }
                });
                subscribers.forEach(async (subscriber) => {
                    if (subscriber.email) {
                        const subject = `⚠️ Alert: ${alert.title} — ${alert.region.toUpperCase()}, ${alert.state}`;

                        // pretty percentage (1 -> 100%)
                        const percent = (alert.mlPrediction * 100);
                        const percentText = `${percent.toFixed(1)}%`;

                        // format date
                        const createdAt = new Date(alert.createdAt ?? Date.now()).toLocaleString();
                        const text = htmlBuilder(alert, createdAt, percentText);
                        await sendEmail(subscriber.email, subject, text);
                    }
                    if (subscriber.phone) {
                        sendSMS(subscriber.phone, `⚠️ Alert: ${alert.title} — ${alert.region.toUpperCase()}, ${alert.state}\n\n${alert.description}\n\nStay safe,\nCoastal Threat Alert System`);
                    }
                    // wait for few seconds before getting api abused.
                    await new Promise(resolve => setTimeout(resolve, 2000));
                })
                return {
                    success: true,
                    alert,
                    message: 'Alert approved successfully',
                };
            } catch (error) {
                console.error('Error approving alert:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to approve alert',
                });
            }
        }),

    // Admin: Reject an alert
    rejectAlert: protectedProcedure
        .input(z.object({
            alertId: z.number(),
            reviewNotes: z.string(),
        }))
        .mutation(async ({ ctx, input }) => {
            const userId = ctx.user?.id;
            if (!userId) {
                throw new TRPCError({ code: 'UNAUTHORIZED', message: 'User not found' });
            }

            try {
                // Check if user is admin
                const user = await ctx.db.user.findUnique({
                    where: { email: ctx.user?.email ?? "" },
                    select: { role: true, id: true },
                });

                if (!user || user.role !== 'ADMIN') {
                    throw new TRPCError({ code: 'FORBIDDEN', message: 'Admin access required' });
                }

                const alert = await ctx.db.alert.update({
                    where: { id: input.alertId },
                    data: {
                        status: 'REJECTED',
                        reviewedById: user.id,
                        reviewNotes: input.reviewNotes,
                    },
                    include: {
                        reviewedBy: {
                            select: {
                                firstName: true,
                                lastName: true,
                            },
                        },
                    },
                });

                return {
                    success: true,
                    alert,
                    message: 'Alert rejected',
                };
            } catch (error) {
                console.error('Error rejecting alert:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to reject alert',
                });
            }
        }),

    // Get alert statistics for dashboard
    getAlertStats: publicProcedure
        .query(async ({ ctx }) => {
            try {
                const [
                    totalGenerated,
                    pendingApproval,
                    totalApproved,
                    totalSent,
                    last24Hours,
                    byType,
                    bySeverity,
                ] = await Promise.all([
                    ctx.db.alert.count({
                        where: { status: 'GENERATED' },
                    }),
                    ctx.db.alert.count({
                        where: { status: 'PENDING_APPROVAL' },
                    }),
                    ctx.db.alert.count({
                        where: { status: 'APPROVED' },
                    }),
                    ctx.db.alert.count({
                        where: { status: 'SENT' },
                    }),
                    ctx.db.alert.count({
                        where: {
                            createdAt: {
                                gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
                            },
                        },
                    }),
                    ctx.db.alert.groupBy({
                        by: ['type'],
                        _count: true,
                    }),
                    ctx.db.alert.groupBy({
                        by: ['severity'],
                        _count: true,
                    }),
                ]);

                return {
                    totalGenerated,
                    pendingApproval,
                    totalApproved,
                    totalSent,
                    last24Hours,
                    byType: byType.reduce((acc, item) => {
                        acc[item.type] = item._count;
                        return acc;
                    }, {} as Record<string, number>),
                    bySeverity: bySeverity.reduce((acc, item) => {
                        acc[item.severity] = item._count;
                        return acc;
                    }, {} as Record<string, number>),
                };
            } catch (error) {
                console.error('Error fetching alert stats:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to fetch alert statistics',
                });
            }
        }),



    // Mark alert as sent (after notification delivery)
    markAlertAsSent: protectedProcedure
        .input(z.object({
            alertId: z.number(),
        }))
        .mutation(async ({ ctx, input }) => {
            try {
                const alert = await ctx.db.alert.update({
                    where: { id: input.alertId },
                    data: {
                        status: 'SENT',
                        sentAt: new Date(),
                    },
                });

                return {
                    success: true,
                    alert,
                };
            } catch (error) {
                console.error('Error marking alert as sent:', error);
                throw new TRPCError({
                    code: 'INTERNAL_SERVER_ERROR',
                    message: 'Failed to mark alert as sent',
                });
            }
        }),

    // Real-time alert monitoring subscription
    subscribeToAlertMonitoring: publicProcedure
        .subscription(() => {
            return observable<any>((emit) => {
                let isActive = true;

                const monitorAndGenerateAlerts = async () => {
                    try {
                        // Generate realistic environmental data for monitoring
                        const cycloneData = {
                            windSpeed: Math.random() * 200, // 0-200 km/h
                            pressure: 950 + Math.random() * 100, // 950-1050 hPa
                            location: { lat: 12.9716, lng: 77.5946 },
                        };

                        const pollutionData = {
                            turbidity: Math.random() * 50, // 0-50 NTU
                            ph: 6 + Math.random() * 3, // 6-9 pH
                            dissolvedOxygen: Math.random() * 15, // 0-15 mg/L
                            location: { lat: 12.9716, lng: 77.5946 },
                        };

                        const stormSurgeData = {
                            waterLevel: Math.random() * 8, // 0-8 meters
                            waveHeight: Math.random() * 6, // 0-6 meters
                            tidalVariation: Math.random() * 2, // 0-2 meters
                            location: { lat: 12.9716, lng: 77.5946 },
                        };

                        const coastalErosionData = {
                            erosionRate: Math.random() * 6, // 0-6 m/year
                            shorelineChange: Math.random() * 10 - 5, // -5 to +5 meters
                            sedimentLoss: Math.random() * 1000, // 0-1000 tons/year
                            location: { lat: 12.9716, lng: 77.5946 },
                        };

                        // Check each type for alerts
                        const alerts = await Promise.all([
                            checkCycloneAlerts(cycloneData),
                            checkPollutionAlerts(pollutionData),
                            checkStormSurgeAlerts(stormSurgeData),
                            checkCoastalErosionAlerts(coastalErosionData),
                        ]);

                        const generatedAlerts = alerts.filter(alert => alert !== null);

                        if (isActive && generatedAlerts.length > 0) {
                            emit.next({
                                type: 'new_alerts_generated',
                                data: generatedAlerts,
                                timestamp: new Date().toISOString(),
                                stats: await getAlertStats(),
                            });
                        }
                    } catch (error) {
                        if (isActive) {
                            emit.error(error);
                        }
                    }
                };

                // Initial check
                monitorAndGenerateAlerts();

                // Monitor every 30 seconds
                const interval = setInterval(monitorAndGenerateAlerts, 30000);

                return () => {
                    isActive = false;
                    clearInterval(interval);
                };
            });
        }),

    // Subscribe to real-time alerts updates
    subscribeToAlerts: publicProcedure
        .input(z.object({
            status: AlertStatusEnum.optional(),
            type: AlertTypeEnum.optional(),
        }))
        .subscription(({ input, ctx }) => {
            return observable<any>((emit) => {
                let isActive = true;

                const checkAndEmitAlerts = async () => {
                    try {
                        const where: any = {};

                        if (input.status) {
                            where.status = input.status;
                        } else {
                            // Default to generated and approved alerts
                            where.status = { in: ['GENERATED', 'PENDING_APPROVAL', 'APPROVED'] };
                        }

                        if (input.type) {
                            where.type = input.type;
                        }

                        const latestAlerts = await ctx.db.alert.findMany({
                            where,
                            orderBy: { createdAt: 'desc' },
                            take: 10,
                            include: {
                                reviewedBy: {
                                    select: {
                                        id: true,
                                        firstName: true,
                                        lastName: true,
                                        role: true,
                                    },
                                },
                            },
                        });

                        if (isActive) {
                            emit.next({
                                type: 'alerts_update',
                                data: latestAlerts,
                                timestamp: new Date().toISOString(),
                            });
                        }
                    } catch (error) {
                        if (isActive) {
                            emit.error(error);
                        }
                    }
                };

                // Initial fetch
                checkAndEmitAlerts();

                // Poll for updates every 15 seconds
                const interval = setInterval(checkAndEmitAlerts, 15000);

                return () => {
                    isActive = false;
                    clearInterval(interval);
                };
            });
        }),
});




function escapeHtml(str: string) {
    if (!str) return '';
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function severityClass(severity: string) {
    switch (severity) {
        case 'LOW': return 'severity-low';
        case 'MODERATE': return 'severity-moderate';
        case 'HIGH': return 'severity-high';
        case 'EXTREME': return 'severity-high';
        default: return '';
    }
}

function formatCoords(coords?: { lat: number; lng: number }) {
    if (!coords) return 'N/A';
    return `${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}`;
}

const htmlBuilder = (alert: any, createdAt: string, percentText: string) => {


    // small inline-email-safe CSS (keeps email clients happier)
    return `
  <!doctype html>
  <html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Alert Notification</title>
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:0; padding:0; background:#f3f7fb; }
      .container { max-width:600px; margin:20px auto; background: #ffffff; border-radius:12px; overflow:hidden; box-shadow: 0 6px 18px rgba(20,40,80,0.08); }
      .header { background: linear-gradient(90deg,#0ea5e9,#6366f1); color: #fff; padding:18px 20px; }
      .title { margin:0; font-size:18px; font-weight:600; letter-spacing: -0.2px; }
      .sub { margin:4px 0 0; font-size:12px; opacity:0.95; }
      .content { padding:18px 20px; color:#0f172a; }
      .badge { display:inline-block; padding:6px 10px; border-radius:999px; font-weight:700; font-size:12px; }
      .severity-low { background:#e6fffa; color:#0f766e; }
      .severity-moderate { background:#fffbeb; color:#92400e; }
      .severity-high { background:#fff1f2; color:#9f1239; }
      .row { display:flex; justify-content:space-between; margin:8px 0; }
      .muted { color:#64748b; font-size:13px; }
      .value { font-weight:700; font-size:15px; color:#0f172a; }
      .box { background:#f8fafc; padding:12px; border-radius:8px; margin-top:12px; }
      .cta { display:inline-block; margin-top:14px; padding:10px 16px; background:#0ea5e9; color:#fff; border-radius:8px; text-decoration:none; font-weight:600; }
      .footer { padding:12px 20px; font-size:12px; color:#94a3b8; text-align:center; }
      table { width:100%; border-collapse:collapse; margin-top:8px; }
      td { padding:6px 0; vertical-align:top; }
      .label { color:#64748b; font-size:13px; width:45%; }
      .val { font-weight:600; color:#0f172a; text-align:right; width:55%; }
      @media (max-width:420px) {
        .row { flex-direction:column; gap:8px; }
        .val { text-align:left; }
      }
    </style>
  </head>
  <body>
    <div class="container" role="article" aria-label="Alert Notification">
      <div class="header">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <div class="title">Coastal Alert: ${escapeHtml(alert.title)}</div>
            <div class="sub">Region: ${escapeHtml(alert.region)}, ${escapeHtml(alert.state)} • ${createdAt}</div>
          </div>
          <div style="text-align:right;">
            <div class="badge ${severityClass(alert.severity)}">${escapeHtml(alert.severity)}</div>
            <div style="font-size:12px; margin-top:6px; opacity:0.95;">ID: ${alert.id}</div>
          </div>
        </div>
      </div>

      <div class="content">
        <p class="muted">We detected an event matching your subscription. Below are the key details & ML confidence.</p>

        <div class="box">
          <div class="row">
            <div>
              <div class="label">Type</div>
              <div class="val">${escapeHtml(alert.type.replace('_', ' '))}</div>
            </div>
            <div>
              <div class="label">ML Prediction</div>
              <div class="val">${percentText}</div>
            </div>
          </div>

          <table>
            <tr>
              <td class="label">Severity</td>
              <td class="val">${escapeHtml(alert.severity)}</td>
            </tr>
            <tr>
              <td class="label">Region</td>
              <td class="val">${escapeHtml(alert.region)}</td>
            </tr>
            <tr>
              <td class="label">State</td>
              <td class="val">${escapeHtml(alert.state)}</td>
            </tr>
            <tr>
              <td class="label">Coordinates</td>
              <td class="val">${formatCoords(alert.coordinates)}</td>
            </tr>
            <tr>
              <td class="label">Threshold Met</td>
              <td class="val">${alert.thresholdMet ? 'Yes' : 'No'}</td>
            </tr>
          </table>

          <div style="margin-top:12px;">
            <div style="font-weight:700; margin-bottom:6px;">Description</div>
            <div class="muted">${escapeHtml(alert.description)}</div>
          </div>

        </div>
      </div>

      <div class="footer">
        This message was generated automatically. If you do not want to receive alerts, manage your subscriptions in the dashboard.
      </div>
    </div>
  </body>
  </html>
  `;
};